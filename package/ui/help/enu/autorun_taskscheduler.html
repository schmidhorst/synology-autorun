<!DOCTYPE html>
<html class="img-no-display" lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link href="../../../../help/help.css" rel="stylesheet" type="text/css">
    <link href="../../../../help/scrollbar/flexcroll.css" rel="stylesheet" type="text/css">
    <script src="../../../../help/scrollbar/flexcroll.js"></script>
    <script src="../../../../help/scrollbar/initFlexcroll.js"></script>
    <title>Autorun</title>
  </head>
  <body>
    <h1>Task scheduler</h1>
    <p>
    Under certain circumstances it is useful to start a task defined in the task scheduler via autorun.    </p>
    <p>
    The shell command to start such a task is e.g. <span style="font-family: 'Courier New'; font-weight: normal; font-style: normal; text-decoration: none;">/usr/syno/bin/synoschedtask --run id=14 check_time=0</span>. The "task ID" (14 in the example) can be determined with <span style="font-family: 'Courier New'; font-weight: normal; font-style: normal; text-decoration: none;">synoschedtask --get</span>. Under certain circumstances it is also useful to execute the command specified as "command" directly and bypass the task scheduler.    </p>
    <p>
    The scheduler's start command is then done in no time and the task runs as an independent process. If you want to use the LED control to indicate the running task or to eject the hard disk after the task has finished, you must wait in your script for the end of the process after the task start with a loop like this:    </p><p>
    
    <span style="font-family: 'Courier New'; font-weight: normal; font-style: normal; text-decoration: none;">sleep 60<br>while [ "$(/bin/pidof <i>&lt;process name&gt;)</i>" ]; do<br>sleep 60<br>done </span>   </p>
  </body>
</html>
