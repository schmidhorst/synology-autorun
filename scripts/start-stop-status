#!/bin/bash

# if the last entry of $SCRIPT_EXEC_LOG contains $1, then remove possibly available $2, append $3 and use that as new last entry
# else write $3 with actual timestamp as new entry
# e.g.  appendToLastLogLineIfSimilar "Re-Installation (change of settings)" "not yet started" "Package '$SYNOPKG_PKGNAME' was STARTED!"
appendToLastLogLineIfSimilar() {
  latestEntry="$(/bin/tail -1 "$SCRIPT_EXEC_LOG")"
  if [[ "$latestEntry" == *"$1"* ]]; then
    # future Option: Check time in $latestEntry and and replace only if not too old
    lineCount=$(/bin/wc -l < "$SCRIPT_EXEC_LOG")
    /bin/sed -i -e "$lineCount,\$d" "$SCRIPT_EXEC_LOG" # remove the last line
    /bin/echo "${latestEntry//$2/} $3" >> "$SCRIPT_EXEC_LOG"
    # logInfo 8 "Last Entry in SCRIPT_EXEC_LOG replaced"
  else
    /bin/echo "$(date "$DTFMT"): $3" >> "$SCRIPT_EXEC_LOG"
    # logInfo 8 "Item '$1' not found in SCRIPT_EXEC_LOG last line: '$latestEntry'"
  fi # if [[ "$latestEntry" == *"$diskName"* ]]
}




# This start-stop-status is called about once per second!
user=$(whoami) # EnvVar $USER may be not well set
# user = "root" if the sudo cp /var/packages/$SYNOPKG_PKGNAME/conf/privilege.root /var/packages/$SYNOPKG_PKGNAME/conf/privilege
# user = "$SYNOPKG_PKGNAME" = '<appName>' if the copy was not done
LOG="/var/tmp/$SYNOPKG_PKGNAME.log"
DTFMT="+%Y-%m-%d %H:%M:%S"
SCRIPTPATHTHIS="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; /bin/pwd -P )" # /var/packages/autorun/scripts !!
SCRIPT_EXEC_LOG="$APPDATA/execLog" # 2022-12-23: "start-stop-status: line 167/168: No such file or directory" found in /var/log/bash_err.log????
ruleDfilePathName="/usr/lib/udev/rules.d/99-$SYNOPKG_PKGNAME.rules"
case $1 in
  prestart)
    echo "$(date "$DTFMT"): PRESTART of start-stop-status script V$SYNOPKG_PKGVER '$1' as user '$user'<br/>" >> "$LOG"
    #### is occuring if in INFO: precheckstartstop="yes"
    ;;
  start)
    configFilePathName="/var/packages/$SYNOPKG_PKGNAME/var/config"
    source "/var/packages/$SYNOPKG_PKGNAME/target/common" start-stop-status # set lngUser
    echo "$(date "$DTFMT"): start-stop-status script V$SYNOPKG_PKGVER '$1' as user '$user'. SYNOPKG_DSM_LANGUAGE='$lngUser'<br/>" >> "$LOG"
    if [ "$user" != "root" ]; then
      echo "$(date "$DTFMT"): start-stop-status '$1' as user '$user' != \"root\". <br/>" >> "$LOG"
      eval $(grep -s "copyPriviledge=" "/var/packages/$SYNOPKG_PKGNAME/target/ui/texts/$lngUser/lang.txt")
      if [ "$copyPriviledge" != "" ]; then
        echo "$copyPriviledge" > "$SYNOPKG_TEMP_LOGFILE"
      else
        echo "The copy command 'cp /var/packages/$SYNOPKG_PKGNAME/conf/privilege.root /var/packages/$SYNOPKG_PKGNAME/conf/privilege' was not yet executed. Therefore the package '$SYNOPKG_PKGNAME' cannot be started" > "$SYNOPKG_TEMP_LOGFILE"
      fi
      # exit 3 # this would run into repair loop and no exit possible except uninstall/re-install
    else # root
      error=0
      # enable log deleting for ui/index.cgi:
      chmod 664 "$LOG"
      chown "$SYNOPKG_PKGNAME":"$SYNOPKG_PKGNAME" "$LOG"
      if [[ ! -L "/var/packages/$SYNOPKG_PKGNAME/var/detailLog" ]]; then
        ln -s "$LOG" "/var/packages/$SYNOPKG_PKGNAME/var/detailLog" # for access from cgi file
      fi
      chmod 644 "/var/packages/$SYNOPKG_PKGNAME/var/detailLog"
      chown --no-dereference "$SYNOPKG_PKGNAME":"$SYNOPKG_PKGNAME" "/var/packages/$SYNOPKG_PKGNAME/var/detailLog"
      eval "$(grep "^SCRIPT=" "$configFilePathName")"
      files="" # list of files, which we want to check for excutable, unix line break and coding
      if [[ "$SCRIPT" == *"/"* ]]; then
        files="$SCRIPT"  # The script to execute at storage connect is on the DSM, so we can check it
      fi
      eval "$(grep "^SCRIPT_AFTER_EJECT=" "$configFilePathName")"
      if [[ -n "$SCRIPT_AFTER_EJECT" ]]; then # script is setup, check it!
        files="$files $SCRIPT_AFTER_EJECT"
        #echo "$(date "$DTFMT"): start-stop-status: Script after eject '$SCRIPT_AFTER_EJECT'<br/>" >> "$LOG"
      #else # if [[ -n "$SCRIPT_AFTER_EJECT" ]]
        #echo "$(date "$DTFMT"): start-stop-status: No script after eject<br/>" >> "$LOG"
      fi # if [[ -n "$SCRIPT_AFTER_EJECT" ]]
      resWhichFile=$(which "file") # Is 'which' always available? 'file' is only available after installation of "SynoCLI File Tools"!
      if [[ -z "$resWhichFile" ]]; then
        echo "$(date "$DTFMT"): Linux command 'file' (part of package 'SynoCli File Tools') is not available. Checking source files for correct line terminator and UTF-8-coding skipped!" >> LOG
      fi
      for f in $files; do # check scripts
        if [[ ! -f "$f" ]]; then
          eval $(grep -s "scriptNA=" "/var/packages/$SYNOPKG_PKGNAME/target/ui/texts/$lngUser/lang.txt")
          echo "$scriptNA" > "$SYNOPKG_TEMP_LOGFILE"
          echo "$(date "$DTFMT"): Error: The script file '$f' is not available!" >> "$LOG"
          res=$(findFileIgnoreCase "$f")
          result=$?
          #echo "$(date "$DTFMT"): findFileIgnoreCase result: $result, '$res'" >> "$LOG"
          if [[ "$result" -eq "1" ]]; then # with "ignore case script found!"
            eval $(grep -s "scriptNAcase=" "/var/packages/$SYNOPKG_PKGNAME/target/ui/texts/$lngUser/lang.txt")
            echo "$(date "$DTFMT"): Suspicious: '$f' with different upper/lower case found: '$res'. It will not be executed!!" >> "$LOG"
            echo "  $scriptNAcase" >> "$SYNOPKG_TEMP_LOGFILE"
          fi
          eval $(grep -s "setupCorrection=" "/var/packages/$SYNOPKG_PKGNAME/target/ui/texts/$lngUser/lang.txt")
          echo " $setupCorrection" >> "$SYNOPKG_TEMP_LOGFILE"
          # exit 2 # this would run into repair loop and no exit possible except uninstall/re-install
          error=1
        elif [[ ! -x "$f" ]]; then
          eval $(grep -s "scriptNexec=" "/var/packages/$SYNOPKG_PKGNAME/target/ui/texts/$lngUser/lang.txt")
          echo "$scriptNexec" > "$SYNOPKG_TEMP_LOGFILE"
          echo "$(date "$DTFMT"): Error: The script file $f is not executable!" >> "$LOG"
          # exit 2 # this would run into repair loop and no exit possible except uninstall/re-install
          error=1
        elif [[ -n "$resWhichFile" ]]; then
          res=$(file -b "$f")
          ret=$?
          echo "$(date "$DTFMT"): File coding check '$f' result $ret: $res" >> "$LOG"
          if [[ $res == *"CRLF line terminators"* ]]; then
            echo "  File coding check '$f' result $ret: $res"
            echo "  ######## Windows line terminator need to be converted to Unix! #########"
            eval $(grep -s "wrongLineBreakWin=" "/var/packages/$SYNOPKG_PKGNAME/target/ui/texts/$lngUser/lang.txt")
            echo "$wrongLineBreakWin" > "$SYNOPKG_TEMP_LOGFILE"
            # exit 2 # this would run into repair loop and no exit possible except uninstall/re-install
            error=1
          elif [[ $res == *"with CR line terminators"* ]]; then
            echo "  File coding check '$f' result $ret: $res"
            echo "  ######## MAC line terminator need to be converted to Unix! #########"
            eval $(grep -s "wrongLineBreakMac=" "/var/packages/$SYNOPKG_PKGNAME/target/ui/texts/$lngUser/lang.txt")
            echo "$wrongLineBreakMac" > "$SYNOPKG_TEMP_LOGFILE"
            # exit 2 # this would run into repair loop and no exit possible except uninstall/re-install
            error=1
          elif [[ "$res" == *"ISO-8859 text"* ]]; then
            echo "  File coding check '$f' result $ret: $res"
            echo "  ######## Please convert to UTF-8! ##########"
            eval $(grep -s "wrongCodePage=" "/var/packages/$SYNOPKG_PKGNAME/target/ui/texts/$lngUser/lang.txt")
            echo "$wrongCodePage" > "$SYNOPKG_TEMP_LOGFILE"
            #exit 2
            error=1
          fi # CRLF
        fi # existing and executable and command 'file' available
      done

      # check whether the entered user/usergroup for desktop notification is valid:
      notyfyUsers=$(grep "^NOTIFY_USERS=" "$configFilePathName")
      notyfyUsers=${notyfyUsers#NOTIFY_USERS=\"}
      notyfyUsers=${notyfyUsers%\"}
      if [[ -n "$notyfyUsers" ]]; then # not empty ==> desktop messages active
        if [[ $notyfyUsers == "@"* ]]; then # Groupname
          # syngroup --enum all requires root access
          groupExist=$(synogroup --enum all | grep "${notyfyUsers:1}") # account which are allowing login
          if [[ -z $groupExist ]]; then # Fehlermeldung
            echo "$(date "$DTFMT"): The group account '$notyfyUsers' for desktop message does not exist! Wrong entry replaced by '@users'" >> "$LOG"
            eval $(grep -s "notifyGroupError=" "/var/packages/$SYNOPKG_PKGNAME/target/ui/texts/$lngUser/lang.txt")
            echo "$notifyGroupError" > "$SYNOPKG_TEMP_LOGFILE"
            sed -i 's/^NOTIFY_USERS=.*$/NOTIFY_USERS=@users/' "$configFilePathName"
          fi
        else # single user
          # userExist=$(grep -o "^${notyfyUsers}:" /etc/passwd) # long list of accounts!
          userExist=$(synouser --enum all | grep "${notyfyUsers}") # account which are allowing login
          # alternative: synouser --get "${notyfyUsers}"
          if [[ -z $userExist ]]; then # Fehlermeldung
            echo "$(date "$DTFMT"): The user account '$notyfyUsers' for desktop messages does not exist! Therefore the wrong entry replaced by '@users'. Run Installation again to enter another value!" >> "$LOG"
            eval $(grep -s "notifyUserError=" "/var/packages/$SYNOPKG_PKGNAME/target/ui/texts/$lngUser/lang.txt")
            echo "$notifyUserError" > "$SYNOPKG_TEMP_LOGFILE"
            sed -i 's/^NOTIFY_USERS=.*$/NOTIFY_USERS=@users/' "$configFilePathName"
          fi # not existing user
        fi # if goupe else user
      fi
    fi # user root
    if [ -f "$ruleDfilePathName" ];  then
      echo "$(date "$DTFMT"): start executed, but app was already running<br/>" >> "$LOG"
      exit 1
    else
      if [[ "$error" -eq "0" ]]; then
        echo "$(date "$DTFMT"): start-stop-status script 'start', SYNOPKG_PKGDEST='$SYNOPKG_PKGDEST'<br/>" >> "$LOG"
        resultStart=$(cp "/var/packages/$SYNOPKG_PKGNAME/target/rules" "$ruleDfilePathName")
        retvalStart=$?
        echo "$(date "$DTFMT"): cp rules to '$ruleDfilePathName': retval=$retvalStart, result='$resultStart'<br/>" >> "$LOG"
        chmod 644 "$ruleDfilePathName"
        # chown root:root "$ruleDfilePathName" # required?
        /usr/bin/udevadm control --reload-rules
        if [ -f "$ruleDfilePathName" ];  then
          # echo "$(date "$DTFMT"): Package '$SYNOPKG_PKGNAME' was STARTED!" >> "$SCRIPT_EXEC_LOG"
          appendToLastLogLineIfSimilar "Re-Installation (change of settings)" "not yet started" "Package '$SYNOPKG_PKGNAME' was STARTED!"
          echo "$(date "$DTFMT"): ... start via start-stop-status script successfully finished<br/>" >> "$LOG"
        fi
      else
        echo "$(date "$DTFMT"): start-stop-status script 'start' failed!<br/>" >> "$LOG"
      fi
    fi
    exit 0
  ;;
  prestop)  # can be disabled via precheckstartstop in INFO file
    #### is not occuring !!!????
    echo "$(date "$DTFMT"): PRESTOP start-stop-status script V$SYNOPKG_PKGVER '$1' as user '$user'<br/>" >> "$LOG"
  ;;
  stop)
    echo "$(date "$DTFMT"): start-stop-status script V$SYNOPKG_PKGVER '$1' as user '$user'<br/>" >> "$LOG"
    if [ -f "/usr/lib/udev/rules.d/99-$SYNOPKG_PKGNAME.rules" ]; then
      resultStop=$(rm -f "/usr/lib/udev/rules.d/99-$SYNOPKG_PKGNAME.rules")
      retvalStop=$?
      echo "$(date "$DTFMT"): rm $(basename "$ruleDfilePathName") retval=$retvalStop, result='$resultStop'<br/>" >> "$LOG"
      /usr/bin/udevadm control --reload-rules
      echo "$(date "$DTFMT"): Package '$SYNOPKG_PKGNAME' was STOPPED!" >> "$SCRIPT_EXEC_LOG"
    else
      echo "$(date "$DTFMT"): stop executed, but app was not running<br/>" >> "$LOG"
    fi
    echo "$(date "$DTFMT"): ... stop via start-stop-status script done<br/>" >> "$LOG"
    exit 0
  ;;
  status)
    if [ -f "$ruleDfilePathName" ]; then
      exit 0
    else
      exit 1
    fi
  ;;
esac

