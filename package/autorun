#!/bin/bash
# https://raw.githubusercontent.com/reidemei/synology-autorun/main/package/autorun
# re-written Horst Schmid 2022-11-25

# default settings
TRIES=20
WAIT=0 # wait (seconds) time after mountpoint found
ADD_NEW_FINGERPRINTS=1 # allow changed or new scripts
FINGERPRINTS_INCL_DRIVE=0 # 0: allow script from any drive
SCRIPT_AFTER_EJECT=""

# $1 is e.g. 'usb1p1'


executeFoundScript(){
  # $1 is e.g. 'usb1p1'
  # run it:
  logInfo "starting now '$MOUNTPATH/$SCRIPT' ..."
  dateStart_s=$(date +"%s")
  dateStart_string=$(date "$DTFMT")
  echo "$(date "$DTFMT"): The script '$SCRIPT' on '$diskName', mounted as $MOUNTPATH, was started and is running ..." >> "$SCRIPT_EXEC_LOG"
  if (((LED & 1)!=0)); then  # by default this LED is OFF of GREEN
    beep LED_STATUS_GREEN
  elif (((LED & 2)!=0)); then  
    beep LED_STATUS_GREEN_FLASH
  fi
  if (((LED_COPY & 1)!=0)); then
    beep LED_COPY_ON
  elif (((LED_COPY & 2)!=0)); then
    beep LED_COPY_FLASH  
  fi  
  /bin/sh "$MOUNTPATH/$SCRIPT" "$MOUNTPATH" "$1" 2>&1 | /bin/tee -a "$LOGFILE"; RESULT=${PIPESTATUS[0]}
  echo "Back in $scriptFullPathName from $MOUNTPATH/$SCRIPT with result='$RESULT'"
  dateFinished_s=$(date +"%s")
  if [[ "$LED" == "1" ]]; then 
    beep LED_STATUS_GREEN_FLASH
  fi
  if (((LED_COPY & 7)!=0)); then
    beep LED_COPY_OFF # Copy LED off
    if [[ "$RESULT" != 0 ]] && [[ "$RESULT" != 100 ]]; then 
      if (((LED_COPY & 4)!=0)); then
        beep LED_COPY_FLASH
      fi
    fi
  fi # if LED_COPY
  execTime_s=$(( dateFinished_s - dateStart_s ))
  if ((execTime_s > 60 )); then
    (( execTime_min = execTime_s / 60 ))
    (( execTime_s = execTime_s % 60 ))
    execTime="${execTime_s}s"
    if ((execTime_min > 60 )); then
      (( execTime_h = execTime_min / 60 ))
      (( execTime_min = execTime_min % 60 ))
      execTime="${execTime_h}h ${execTime_min}min $execTime"              
    else
      execTime="${execTime_min}min $execTime"              
    fi
  else
    execTime="$execTime_s seconds"
  fi 
  #echo "$(date "$DTFMT"): The script '$SCRIPT' on '$diskName', mounted as $MOUNTPATH, was finished after $execTime with return code $RESULT" >> "$SCRIPT_EXEC_LOG"
  # get the free space
  FREE=$(/bin/df -h "$MOUNTPATH" | /bin/grep "$MOUNTPATH" | /bin/awk '{ print $4 }')  # e.g. "2.1T"
  ejected=0 # 0: no eject, 1: ejecting, 2: eject success, 3: eject fail
  # unmount when the result is 100
  if [ "$RESULT" == "100" ]; then
    echo "Result 100 detected"
    if [ "$LED" = "1" ];then
      # beep 5 # Power LED flashing
      beep LED_STATUS_GREEN_FLASH
    fi
    logInfo 2 "device '$1' - script '$MOUNTPATH/$SCRIPT' finished with $RESULT ($FREE left on device), starting unmount"
    d1=$(/bin/echo "$1" | /bin/sed 's:/dev/::' | /bin/sed 's:p.*::') # d1 is now e.g. 'usb1'
    info=$(/usr/syno/bin/synousbdisk -info "$d1")
    sn=$(/bin/echo "$info" | /bin/grep "Share Name:") # catch line with the share name
    sn=${sn#*:} # remove the label
    sn=$(/bin/echo "$sn") # remove blanks, so we get e.g. usbshare4
    ejected=1  # 0: no eject, 1: ejecting, 2: eject success, 3: eject fail
    endTime=$(($(date +%s) + EJECT_TIMEOUT))
    k=$TRIES # $TRIES is from the config file
    while [[ $(date +%s) -le $endTime ]]; do # loop with counter as the external drive may be in use ...
      # try to do the unmount
      logInfo 8 "till eject timeout left $(( endTime - $(date +%s) ))"
      /bin/sleep 3
      /bin/sync
      /bin/sleep 6
      /usr/syno/bin/synousbdisk -rcclean
      /bin/sleep 6

      # /bin/umount $MOUNTPATH
      resultd=$(/usr/syno/bin/synousbdisk -umount "$d1")
      retvald=$?
      if [ $retvald -eq 0 ];then # success
        # 2nd Part of umount (neccessary?)
        results=$(/usr/syno/bin/synousbdisk -umount "$sn")
        retvals=$?
      fi
      sleep 45
      logInfo 4 "Loop $k: synousbdisk -umount $d1 was $retvald ($resultd), synousbdisk -umount $sn was $retvals (results)"
      # check whether now realy no more mounted:	 
      resultm=$(/bin/mount 2>&1 | /bin/grep "/dev/$1" | /bin/cut -d ' ' -f3)
      if [ -z "$resultm" ]; then # synousbdisk -umount was really successfull
        logInfo 4 "Updating now /tmp/usbtab ..."
        ejected=2 # 0: no eject, 1: ejecting, 2: eject success, 3: eject fail
        # Remove it now from the 'gui' list:
        cp /tmp/usbtab /tmp/usbtab.old
        /bin/grep -v "$d1" /tmp/usbtab.old > /tmp/usbtab  # copy all non-matching lines 
        rm -f /tmp/usbtab.old
        # unbind ??? # Optional !!!????
        logInfo 2 "device '$1' successfully unmounted and removed from GUI!"
        break
      fi
    if [[ $ejected -eq 1 ]]; then
      echo 4 "Drive seems busy! k=$k Please wait ..."
    fi  
    sleep 60
    ((k--))
    done # while not timeout 
    if [[ $ejected -eq 1 ]]; then
      echo "$(date "$DTFMT"): The script '$SCRIPT' on '$diskName', mounted as $MOUNTPATH, was finished after $execTime with return code $RESULT. Attention: The requested ejection of the device failed!!" >> "$SCRIPT_EXEC_LOG"
      ejected=3 # failed
    fi
    logInfo 4 "Eject part finisched with $ejected. (0: no eject, 2: eject success, 3: eject fail) "
    if [[ -n "$SCRIPT_AFTER_EJECT" ]]; then
      if [ -x "$SCRIPT_AFTER_EJECT" ]; then
        # logInfo "ejected=$ejected"
        if [[ $ejected -eq 2 ]]; then
          logInfo 3 "Script '$SCRIPT_AFTER_EJECT' will be started without parameter!"
          sh "$SCRIPT_AFTER_EJECT"
					res="$?"
          # delete the previous log line with script start info
          # head -n -1 input.txt > tmp.txt && mv tmp.txt input.txt
          lineCount=$(wc -l < "$SCRIPT_EXEC_LOG")
          sed -i -e "$lineCount,\$d" "$SCRIPT_EXEC_LOG"					
          echo "$(date "$DTFMT"): The script '$SCRIPT' on '$diskName', mounted as $MOUNTPATH, was started $dateStart_string and finished after $execTime with return code $RESULT. Device successfully ejected and the script '$SCRIPT_AFTER_EJECT' done with return code $res" >> "$SCRIPT_EXEC_LOG"
        else
          logInfo 3 "Script '$SCRIPT_AFTER_EJECT' will be started with 'Ejection failed'!"
          sh "$SCRIPT_AFTER_EJECT" "Ejection failed"
          echo "$(date "$DTFMT"): The script '$SCRIPT' on '$diskName', mounted as $MOUNTPATH, was finished after $execTime with return code $RESULT. Device ejecting was failing. The script '$SCRIPT_AFTER_EJECT' with parameter 'Ejection failed' done." >> "$SCRIPT_EXEC_LOG"          
        fi
      else
        logError "The script '$SCRIPT_AFTER_EJECT' is not executable for actual user"
        if [[ -n "$NOTIFY_USERS" ]]; then
          /usr/syno/bin/synodsmnotify -c "$dsmappname" "$NOTIFY_USERS" "$SYNOPKG_PKGNAME:app1:title01" "$SYNOPKG_PKGNAME:app1:msg10" "$SYNOPKG_PKGNAME" "$SCRIPT" "$SCRIPT_AFTER_EJECT"
        fi     
      fi
    else
      logInfo 3 "No SCRIPT_AFTER_EJECT specified"
      echo "$(date "$DTFMT"): The script '$SCRIPT' on '$diskName', mounted as $MOUNTPATH, was finished after $execTime with return code $RESULT" >> "$SCRIPT_EXEC_LOG"
    fi

    if [[ $ejected -eq 3 ]]; then
      # Ejection of device failed!
      if [[ -n "$NOTIFY_USERS" ]]; then
        /usr/syno/bin/synodsmnotify -c "$dsmappname" "$NOTIFY_USERS" "$SYNOPKG_PKGNAME:app1:title01" "$SYNOPKG_PKGNAME:app1:msg7" "$SCRIPT" "$MOUNTPATH" "$RESULT"
      fi       
      echo "$(date "$DTFMT"): Ejection of '$diskName', mounted as $MOUNTPATH failed!" >> "$SCRIPT_EXEC_LOG"
    else
      if [[ -n "$NOTIFY_USERS" ]] && [[ ";$NO_DSM_MESSAGE_RETURN_CODES;" != *";$RESULT;"* ]]; then
        /usr/syno/bin/synodsmnotify -c "$dsmappname" "$NOTIFY_USERS" "$SYNOPKG_PKGNAME:app1:title01" "$SYNOPKG_PKGNAME:app1:msg8" "$SCRIPT" "$MOUNTPATH" "$RESULT" "$FREE"
      fi       
    fi
  else 
    echo "$(date "$DTFMT"): The script '$SCRIPT' on '$diskName', mounted as $MOUNTPATH, was finished after $execTime with return code $RESULT" >> "$SCRIPT_EXEC_LOG"
    echo "Result != 100"
    logInfo "device '$1' - script '$MOUNTPATH/$SCRIPT' finished with $RESULT ($FREE left on device), no unmount requested"
    if [[ -n "$NOTIFY_USERS" ]] && [[ ";$NO_DSM_MESSAGE_RETURN_CODES;" != *";$RESULT;"* ]]; then
      /usr/syno/bin/synodsmnotify -c "$dsmappname" "$NOTIFY_USERS" "$SYNOPKG_PKGNAME:app1:title01" "$SYNOPKG_PKGNAME:app1:msg9" "$SCRIPT" "$MOUNTPATH" "$RESULT" "$FREE"
    fi       
  fi

  if [[ "$LED" -ne "0" ]]; then
    if [[ $ejected -eq 3 ]]; then  # failure during ejection
      beep LED_STATUS_ORANGE_FLASH
    elif [[ "$LED" == "2" ]]; then
      if [[ "$RESULT" == "100" ]] || [[ "$RESULT" == "0" ]]; then
        beep LED_STATUS_GREEN
      else
        beep LED_STATUS_ORANGE_FLASH
      fi
    else        
      if [[ "$RESULT" == "100" ]] || [[ "$RESULT" == "0" ]]; then
        beep LED_STATUS_OFF
      else
        beep LED_STATUS_ORANGE_FLASH      
      fi
    fi
  fi 
  if (((LED & 1)!=0)); then
    beep LED_STATUS_GREEN
  fi
  if (((LED_COPY & 3)!=0)); then
    beep LED_COPY_OFF
  fi  
} # executeFoundScript()


########################################### start point #####################
# environment PATH is empty when started via event!!!

SCRIPTPATHTHIS="$( cd -- "$(dirname "$0")" >/dev/null 2>&1 ; pwd -P )" # e.g. /volumeX/@appstore/<app>
baseNameThis="$(basename "$0")"
scriptFullPathName=$SCRIPTPATHTHIS/$baseNameThis # with physical path
if [[ -z "$SYNOPKG_PKGNAME" ]]; then
  SYNOPKG_PKGNAME=${SCRIPTPATHTHIS##*/}
  myMsg="SYNOPKG_PKGNAME='$SYNOPKG_PKGNAME' extracted from SCRIPTPATHTHIS"  
else
  myMsg="SYNOPKG_PKGNAME='$SYNOPKG_PKGNAME' was available"  
fi
source "/var/packages/$SYNOPKG_PKGNAME/var/config" # import our config

# import helper functions logInfo(), logError(), beepError() and beep() (also used for LED control): 
if [[ ! -x "/var/packages/$SYNOPKG_PKGNAME/target/common" ]]; then
  echo "###########################################################################"
  echo "Error: File '/var/packages/$SYNOPKG_PKGNAME/target/common' not available or not executable!" | tail -a "/var/log/packages/$SYNOPKG_PKGNAME.log"
  echo "###########################################################################"
  exit 1
fi
source "/var/packages/$SYNOPKG_PKGNAME/target/common" # lngUser, lngMail (for Logfile) set, $APPDATA/config read
/bin/echo -e "" >> "$LOGFILE" # empty row
logInfo 2 "Start of $0 ..."
logInfo 4 "$myMsg"
if [ -z "$1" ]; then
  echo "incorrect '\$1' - aborting ..."
  logError ""
  logError "#######################################"
  logError "Error: Parameter 1 missing in $0"
  beepError
  exit 1
fi

MOUNTPATH=""
eval "$(grep "dsmappname=" "/var/packages/$SYNOPKG_PKGNAME/INFO")"
logInfo 4 "The 'dsmappname', the class for synodsmnotify is '$dsmappname'"
# dsmappname needs to match the .url in ui/config. Otherwise synodsmnotify will not work 
# used as CLASS in synodsmnotify
COUNT=0
SCRIPT_EXEC_LOG="$APPDATA/execLog" # logfile with 1 ..2 lines per executed script
if [[ -f "$SCRIPT_EXEC_LOG" ]]; then
  logInfo 6 "File $SCRIPT_EXEC_LOG exists"
  lineCount=$(wc -l < "$SCRIPT_EXEC_LOG")   
  logInfo 6 "The log file '$SCRIPT_EXEC_LOG' has $lineCount lines"
  echo "lineCount=$lineCount"
  if [[ "$lineCount" -gt "$LOG_MAX_LINES" ]]; then
    newLineCount=$((LOG_MAX_LINES / 2))  
    delLines=$((lineCount - newLineCount))
    sed -i -e "1,${delLines}d" "$SCRIPT_EXEC_LOG"
    logInfo 2 "The log file '$SCRIPT_EXEC_LOG' was trimmed from $lineCount to $newLineCount lines"
  fi 
else
  touch "$SCRIPT_EXEC_LOG" # created an empty file
  chown "$SYNOPKG_PKGNAME":"$SYNOPKG_PKGNAME" "$SCRIPT_EXEC_LOG" # make it accessable & readable for the cgi scripts
  chmod 644 "$SCRIPT_EXEC_LOG"
fi

if [[ -f "$LOG" ]]; then
  lineCount=$(wc -l < "$LOG")
  logInfo 6 "The log file '$LOG' has $lineCount lines"
  if [[ $lineCount -gt "$LOG_MAX_LINES" ]]; then
    newLineCount=$((LOG_MAX_LINES / 2))  
    delLines=$((lineCount - newLineCount))
    sed -i -e "1,${delLines}d" "$LOG"
    logInfo 2 "The log file '$LOG' was trimmed from $lineCount to $newLineCount lines"
  fi 
else
  touch "$LOG"
  chown "$SYNOPKG_PKGNAME":"$SYNOPKG_PKGNAME" "$LOG"
  chmod 644 "$LOG"
fi
 
# try to get the mount path
logInfo 2 "device '$1' - inserted, trying to find mount point"
COUNT=0
while [ -z "$MOUNTPATH" ] && [ $COUNT -lt $TRIES ]
do
  MOUNTPATH=$(/bin/mount 2>&1 | /bin/grep "/dev/$1" | /bin/cut -d ' ' -f3)
	COUNT=$((COUNT+1))
	/bin/sleep 4s  # acc. V1.8.1
done

# abort when nothing is found
if [ -z "$MOUNTPATH" ]; then
	logError "device '$1' - unable to find mount point within $COUNT seconds, aborting"
  beepError
	exit 1
fi
logInfo 2 "device '$1' - mount point '$MOUNTPATH' found after $COUNT seconds"

# sleep some time because Synology does some crazy stuff like un- and remounting on SATA
/bin/sleep $WAIT
bError=0
usbNo=${MOUNTPATH%/*} # remove /usbshare from e.g. /volumeUSB2/ussbshare
usbNo=${usbNo#*volumeUSB}
# echo "usbNo=$usbNo"
diskID=$(grep "${usbNo=}" "/usr/syno/etc/usbno_guid.map") # e.g. 14="20190123456780"
diskID=${diskID%0\"}
diskID=${diskID#*=\"} # e.g. "2019012345678"
# echo "diskID=$diskID"
diskName=$(/usr/syno/bin/lsusb | grep "$diskID") # e.g. "|__2-2.2 1234:5678:90AB 00 3.00 5000MBit/s 8mA 1IF (...)"
diskName=${diskName#*(}
diskName=${diskName%)*}
# echo "diskName=$diskName" # e.g. "Intenso external USB 3.0 2019012345678"

# is there a script on our drive?
if [ -x "$MOUNTPATH/$SCRIPT" ];then
  logInfo 3 "device '$1' - executable script '$MOUNTPATH/$SCRIPT' found"
  if [ "$BEEP" == "true" ]; then
    beep "$BEEP_SHORT"
  fi
  if [ "$LED" = "1" ]; then
    beep "$LED_STATUS_ORANGE"
  fi

  # Security feature (check checksum of script), similar to
  # https://github.com/JC-23/synology-autorun/releases/tag/v1.9-beta
  ####################################################################
  KNOWNSCRIPTSFILEPATHNAME=$APPDATA/FINGERPRINTS
  ENTRY_COUNT=0
  if [ -f "$KNOWNSCRIPTSFILEPATHNAME" ]; then  # FingerprintFile is available
    ENTRY_COUNT=$(wc -l < "$KNOWNSCRIPTSFILEPATHNAME")
    logInfo 6 "Fingerprint file has $ENTRY_COUNT lines"
  fi

  # Calculate the hash of the scriptfile on USB disk:
  FINGERPRINT1=$(/bin/sha256sum "$MOUNTPATH/$SCRIPT" | /bin/awk '{print $1}')
  logInfo 3 "Fingerprint of '$MOUNTPATH/$SCRIPT' is $FINGERPRINT1"

  if [[ FINGERPRINTS_INCL_DRIVE -eq 1 ]]; then # this feature is not supported by GUI
    FINGERPRINT2="$FINGERPRINT1 $MOUNTPATH" # check kombination of mount path and hash
  else
    FINGERPRINT2="$FINGERPRINT1"
  fi
  scriptDateLastChange=$(date -r "$MOUNTPATH/$SCRIPT" '+%Y-%m-%d %H:%M:%S')
  bExec=0 # preset: don't execute the script
  if [[ "$ADD_NEW_FINGERPRINTS" -eq "0" ]]; then
    bExec=1 # execute any script matching the configured name
  fi

  # Is the finger print of the actual script file already registered?
  line=""
  if [ -f "$KNOWNSCRIPTSFILEPATHNAME" ]; then  # FingerprintFile is available
    # check whether the hash of the actual script on USB is already registerd
    line=$(/bin/grep "$FINGERPRINT2" "$KNOWNSCRIPTSFILEPATHNAME")
    logInfo 5 "Matching Fingerprint line: '$line'"
    line=${line%%#*} # remove comments
    line=${line%% } # trim    
    logInfo 5 "Fingerprint line with removed comment: '$line'"
  fi  

  logInfo 6 "ADD_NEW_FINGERPRINTS='$ADD_NEW_FINGERPRINTS'"
  if [[ "$ADD_NEW_FINGERPRINTS" -eq 1 ]]; then
    if [[ "$ENTRY_COUNT" -eq 0 ]]; then
      # no old fingerprints: add the new one including some details as comment ...
      echo "$FINGERPRINT1 # $(date "$DTFMT") added from $diskName for $SCRIPT ($scriptDateLastChange)" > "$KNOWNSCRIPTSFILEPATHNAME"
      chmod 644 "$KNOWNSCRIPTSFILEPATHNAME"
      logInfo 3 "New fingerprint of '$MOUNTPATH/$SCRIPT' registered"
      echo "$(date "$DTFMT"): The fingerprint of the script '$SCRIPT' ($scriptDateLastChange) on '$diskName', mounted as $MOUNTPATH was now registered as allowed fingerprint." >> "$SCRIPT_EXEC_LOG"
      if [[ -n "$NOTIFY_USERS" ]]; then
        /usr/syno/bin/synodsmnotify -c "$dsmappname" "$NOTIFY_USERS" "$SYNOPKG_PKGNAME:app1:title01" "$SYNOPKG_PKGNAME:app1:msg3" "$SCRIPT" "$scriptDateLastChange"
      fi  
      bExec=1      
    elif [[ "$line" != "" ]]; then # this is the already registered skript 
      logInfo 5 "As '$line' is not empty this is an allowed fingerprint"
      bExec=1        
    fi
  fi # if [[ "$ADD_NEW_FINGERPRINTS" -eq 1 ]]

  if [[ "$ADD_NEW_FINGERPRINTS" -eq "2" ]]; then
    bExec=1 # execute any script matching the configured name and add the fingerprint if not already available
    if [[ "$line" == "" ]]; then
      echo "$FINGERPRINT2 # $(date "$DTFMT") added from $diskName for $SCRIPT $(date -r "$SCRIPT" '+%Y-%m-%d %H:%M:%S')" >> "$KNOWNSCRIPTSFILEPATHNAME"
      logInfo 3 "New fingerprint of '$MOUNTPATH/$SCRIPT' registered"
      echo "$(date "$DTFMT"): The fingerprint of the script '$SCRIPT' on '$diskName', mounted as $MOUNTPATH was now registered as additionally allowed fingerprint." >> "$SCRIPT_EXEC_LOG"
      if [[ -n "$NOTIFY_USERS" ]]; then
        /usr/syno/bin/synodsmnotify -c "$dsmappname" "$NOTIFY_USERS" "$SYNOPKG_PKGNAME:app1:title01" "$SYNOPKG_PKGNAME:app1:msg3" "$SCRIPT" "$scriptDateLastChange"
      fi        
    fi
  elif [[ "$ADD_NEW_FINGERPRINTS" -eq "3" ]]; then
    # allow only previously registerd fingerprints
    if [[ "$line" != "" ]]; then 
      logInfo 3 "Fingerprint of '$MOUNTPATH/$SCRIPT' already known"
      bExec=1
    fi
  fi

  bError=0
  if [[ "$bExec" == "1" ]];then
    scriptName="$MOUNTPATH/$SCRIPT"
    res=$(file -b "$scriptName")
    ret=$?
    logInfo 5 "File coding check '$scriptName' result $ret: $res"
    if [[ $res == *"CRLF line terminators"* ]]; then # Windows Format
      bExec=0 # don't try to execute the script
      logInfo 1 "######## Windows line terminator need to be converted to Unix! #########"
      if [[ -n "$NOTIFY_USERS" ]]; then
        /usr/syno/bin/synodsmnotify -c "$dsmappname" "$NOTIFY_USERS" "$SYNOPKG_PKGNAME:app1:title01" "$SYNOPKG_PKGNAME:app1:msg14" "$scriptName"
      fi        
      echo "$(date "$DTFMT"): Error: The Skript '$scriptName', which should be executed, uses the wrong line break CR/LF (Windows). Please use a siutable Editor (Linux oder Windows Notepad++, PSPad, ...) to change it to LF (UNIX)!" >> "$SCRIPT_EXEC_LOG"      
      bError=1
    elif [[ $res == *"CR line terminators"* ]]; then # MAC format
      bExec=0 # don't try to execute the script
      logInfo 1 "######## MAC line terminator need to be converted to Unix! #########"
      if [[ -n "$NOTIFY_USERS" ]]; then
        /usr/syno/bin/synodsmnotify -c "$dsmappname" "$NOTIFY_USERS" "$SYNOPKG_PKGNAME:app1:title01" "$SYNOPKG_PKGNAME:app1:msg16" "$scriptName"
      fi        
      echo "$(date "$DTFMT"): Error: The Skript '$scriptName', which should be executed, uses the wrong line break CR (MAC). Please use a siutable Editor to change it to LF (UNIX)!" >> "$SCRIPT_EXEC_LOG"      
      bError=1
    elif [[ "$res" == *"ISO-8859 text"* ]]; then 
      bExec=0 # don't try to execute the script
      logInfo 1 "File coding check '$scriptName' result $ret: $res"
      logInfo 1 "######## Please convert to UTF-8! ##########"
      if [[ -n "$NOTIFY_USERS" ]]; then
        /usr/syno/bin/synodsmnotify -c "$dsmappname" "$NOTIFY_USERS" "$SYNOPKG_PKGNAME:app1:title01" "$SYNOPKG_PKGNAME:app1:msg15" "$scriptName"
      fi        
      echo "$(date "$DTFMT"): Error: The Skript '$scriptName', which should be executed, uses the wrong coding (Windows ISO-8859). Please use a siutable Editor (Linux oder Windows Notepad++, PSPad, ...) to change it to UTF-8!" >> "$SCRIPT_EXEC_LOG"      
      bError=1
    fi        
  fi
  if [[ "$bExec" == "1" ]]; then
    # execute the script, $1 = mount path
    executeFoundScript "$1"
  else
    if [[ "$bError" == "0" ]]; then
      echo "$(date "$DTFMT"): The script '$SCRIPT' ($scriptDateLastChange) on '$diskName' with fingerprint $FINGERPRINT1, mounted as $MOUNTPATH does not match registered fingerprints" >> "$SCRIPT_EXEC_LOG"
      if [[ FINGERPRINTS_INCL_DRIVE -eq 1 ]]; then
        logInfo 1 "This skript on '$diskName' ($scriptDateLastChange) with fingerprint $FINGERPRINT1 is not permitted to run from $MOUNTPATH/$SCRIPT. No autorun!"
        if [[ -n "$NOTIFY_USERS" ]]; then
          /usr/syno/bin/synodsmnotify -c "$dsmappname" "$NOTIFY_USERS" "$SYNOPKG_PKGNAME:app1:title01" "$SYNOPKG_PKGNAME:app1:msg5" "$SYNOPKG_PKGNAME" "$SCRIPT" "$MOUNTPATH"
        fi      
      else
        logInfo 1 "This skript '$SCRIPT' ($scriptDateLastChange) on '$diskName' with fingerprint $FINGERPRINT1 with it's fingerprint is not permitted to run. No autorun!"
        if [[ -n "$NOTIFY_USERS" ]]; then
          /usr/syno/bin/synodsmnotify -c "$dsmappname" "$NOTIFY_USERS" "$SYNOPKG_PKGNAME:app1:title01" "$SYNOPKG_PKGNAME:app1:msg4" "$SYNOPKG_PKGNAME" "$SCRIPT" "$scriptDateLastChange"
        fi      
      fi  
    fi
    bError=1
  fi # if [[ "$bExec" == "1" ]]

  if [ "$BEEP" == "true" ];then
    if [ "$bError" == 1 ];then
      beepError
    else
      beep BEEP_SHORT  # short beep
    fi  
  fi
  if [ "$LED" == 1 ];then
    if [ "$bError" == 1 ];then
      beep LED_STATUS_ORANGE_FLASH
    else
      beep LED_STATUS_GREEN
    fi
  fi
else # no executable script 
  if [ -f "$MOUNTPATH/$SCRIPT" ];then
    logInfo 0 "The script file '$MOUNTPATH/$SCRIPT' on $1 is not executable. Exiting from $SYNOPKG_PKGNAME now."
    echo "$(date "$DTFMT"): The script '$SCRIPT' on '$diskName', mounted as $MOUNTPATH is not executable" >> "$SCRIPT_EXEC_LOG"
    if [[ -n "$NOTIFY_USERS" ]]; then
      /usr/syno/bin/synodsmnotify -c "$dsmappname" "$NOTIFY_USERS" "$SYNOPKG_PKGNAME:app1:title01" "$SYNOPKG_PKGNAME:app1:msg6" "$SCRIPT"
    fi        
  else
    logInfo 2 "On the device '$1' there is no file '$MOUNTPATH/$SCRIPT'. Exiting from $SYNOPKG_PKGNAME now."
    echo "$(date "$DTFMT"): There is no script '$SCRIPT' on '$diskName', mounted as $MOUNTPATH" >> "$SCRIPT_EXEC_LOG"
  fi 
fi # script available on USB disk
exit 0

